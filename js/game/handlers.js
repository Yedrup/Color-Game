import { game, evaluateAnswer } from './lib';
import {
  gameFieldSetEl,
  playerColorBlocEl,
  buttonSubmitEl,
  messageBoxEl,
} from '../game/elements';
import { updateTriesRemaining } from './countOfTries';
import { timeoutId, intervalId } from './timeout';
import { createEndGameMessage } from '../data/texts';

function handleSubmit(e) {
  e.preventDefault();
  const { formatColor, namePropertiesToFind } = game;
  const inputs = e.target.elements;
  // get the colors given by the player
  const valuesPlayer = namePropertiesToFind.reduce((acc, color) => {
    let currentInput = inputs[color];
    let isNumber = currentInput.type === 'number';
    let playerInputVal = isNumber
      ? parseInt(currentInput.value)
      : currentInput.value.toLowerCase();

    currentInput.setAttribute('value', currentInput.value);

    return { ...acc, [color]: playerInputVal };
  }, {});
  const colorGeneratedByPlayerString = formatColor(valuesPlayer);
  // add background color generated by the player
  playerColorBlocEl.style.background = colorGeneratedByPlayerString;
  // evaluate answer
  evaluateAnswer(valuesPlayer, game.colorToFind);
  if (game.mode.isCountOfTries) {
    updateTriesRemaining();
  }
}

function handleInputFocus(e) {
  e.target.select();
}

// TODO: Reset the game
function handleReset(e) {
  console.log('reset all value');
  // lib game resetGame()
}

function handleEndOfGame(event) {
  gameFieldSetEl.disabled = true;
  buttonSubmitEl.disabled = true;

  if (game.mode.isTimeout) {
    const { timeoutID = timeoutId, intervalID = intervalId } = event.detail;
    clearTimeout(timeoutID);
    clearInterval(intervalID);
  }
  const finalMessage = createEndGameMessage(event, game);
  messageBoxEl.innerHTML = finalMessage;
  messageBoxEl.hidden = false;
  // TODO: Manage Previous scores in LS (keep the 10 last best scores for each mode)
  // TODO: Display a restart button AND a go back to the select page
}

export { handleSubmit, handleEndOfGame, handleInputFocus };
