import { generateRandom, colorIcon, createRefElObject } from './utils';
import { modeTest } from './dataPattern.js';
// TODO: conditional import
import { gameRBG, gameHSL, gameHEXA } from './games.js';
// TODO: logic to have the mode and game selected

const gameBoardEl = document.querySelector('.game-board');
const gameFormEl = document.createElement('form');
const gameFieldSetEl = document.createElement('fieldset');

let playerColorBlocEl;
let colorInputsElRefObj = {};
let messageDisplayEls = {};
let colorsRemainingToFind;
let game;

function generateInputsHTML(inputsArray) {
  return inputsArray
    .map(({ name, maxValue, valueType, pattern = null }) => {
      return `
      <div class="input__parent input__parent--${name}">
        <label name=${name}>${name}</label>
        <input class="input--color input--color--${name}" ${
        pattern ? (pattern = pattern) : ''
      } type=${valueType} name=${name} value=${generateRandom(
        255
      )} required max=${maxValue}/>
      <span id="message-el-${name}" class="message-input-to-display"></span>
      </div>
      `;
    })
    .join('');
}

function displayMessage(message, color) {
  console.log(message, color);
  if (!color) console.log('display in a general element');
  let displayMessageEl = messageDisplayEls[`message-el-${color}`];
  console.log(colorInputsElRefObj[color], displayMessageEl);
  displayMessageEl.textContent = message;
}

function colorFound(color) {
  console.log('colorFound ✅', colorInputsElRefObj[color]);
  colorInputsElRefObj[color].disabled = true;
  let updatedNamePropertiesToFind = colorsRemainingToFind.filter(
    (curr) => curr !== color
  );
  console.log(updatedNamePropertiesToFind);
  colorsRemainingToFind = updatedNamePropertiesToFind;
  if (!updatedNamePropertiesToFind.length) {
    // the game is finished, event endOfGame triggered
    gameBoardEl.dispatchEvent(
      new CustomEvent('endOfGame', {
        detail: {
          victory: true,
          result: 'this is a great success',
        },
      })
    );
    return;
  }
}

function evaluateAnswer(colorPlayer, colorToFind) {
  console.log({ colorPlayer, colorToFind });
  Object.keys(colorPlayer).forEach((color) => {
    let isTheSameColor = colorPlayer[color] === colorToFind[color];
    if (isTheSameColor) {
      // manage a color found
      colorFound(color);
      displayMessage('✅', color);
      return;
    } else if (colorPlayer[color] < colorToFind[color]) {
      displayMessage(`⬆️ ${colorIcon[color]}`, color);
    } else if (colorPlayer[color] > colorToFind[color]) {
      displayMessage(`⬇️ ${colorIcon[color]}`, color);
    } else {
      console.log(
        'something went wrong',
        colorPlayer[color],
        colorToFind[color]
      );
    }
  });
}

function handleSubmit(e) {
  e.preventDefault();
  console.dir(e);
  console.log('game', game);
  const { formatColor, namePropertiesToFind } = game;
  const inputs = e.target.elements;
  // get the colors given by the player
  const valuesPlayer = namePropertiesToFind.reduce((acc, color) => {
    let isNumber = inputs[color].type === 'number';
    let playerInputVal = isNumber
      ? parseInt(inputs[color].value)
      : inputs[color].value.toLowerCase();

    inputs[color].setAttribute('value', inputs[color].value);

    return { ...acc, [color]: playerInputVal };
  }, {});
  const colorGeneratedByPlayerString = formatColor(valuesPlayer);
  // add background color generated by the player
  playerColorBlocEl.style.background = colorGeneratedByPlayerString;
  // evaluate answer
  evaluateAnswer(valuesPlayer, game.colorToFind);
}

function setForm() {
  gameBoardEl.insertAdjacentElement('beforeend', gameFormEl);
  gameFormEl.classList.add(`game-form`, `game-form--${game.name}`);
  gameFormEl.setAttribute('autocomplete', 'off');
  gameFormEl.insertAdjacentElement('afterbegin', gameFieldSetEl);

  const inputsToCreate = generateInputsHTML(game.UI.inputs);
  const validateInput = `<input value=submit type="submit"/>`;
  document.body.style.background = game.colorToFind.string;

  const allHTML = inputsToCreate + validateInput;
  gameFieldSetEl.innerHTML = allHTML;

  // create objects of refs for input and message
  colorInputsElRefObj = createRefElObject('input.input--color');
  messageDisplayEls = createRefElObject('.message-input-to-display', 'id');
}

function setTheBoard() {
  const titleHTMl = `<h2 class="game__title">${game.UI.title}</h2>`;
  const playerColorBloc = `<div class="bloc-player-color"><span>color you've created</span></div>`;
  gameBoardEl.innerHTML = titleHTMl + playerColorBloc;
  playerColorBlocEl = document.querySelector('.bloc-player-color');
  setForm();
  gameBoardEl.hidden = false;
}

function handleEndOfGame(event) {
  console.log('THIS is the end', event);
  gameFieldSetEl.disabled = true;
  // clear board
  // display message
  /* finish the game
   * display message + score
   * save in LS
   */
}

function gameLifeCycle() {
  gameFormEl.addEventListener('submit', handleSubmit);
  gameBoardEl.addEventListener('endOfGame', handleEndOfGame);
}
function prepareGame(gameSelected, modeSelected) {
  game = {
    ...gameSelected,
    mode: { ...modeSelected },
  };
  // generate color
  game.colorToFind = game.generateColor();
  colorsRemainingToFind = game.namePropertiesToFind;
  // set the board
  setTheBoard();
  gameLifeCycle();
}

// TODO: START When the player has selected the game + its mode
prepareGame(gameRBG, modeTest);
// prepareGame(gameHSL, modeTest);
// prepareGame(gameHEXA, modeTest);

// TEST

// const timoutInMS = 12000;
// setTimeout(() => {
//   gameBoardEl.dispatchEvent(
//     new CustomEvent('endOfGame', {
//       detail: {
//         victory: false,
//         cause: 'TIMEOUT',
//       },
//     })
//   );
// }, timoutInMS);
