import { modeTest } from './data/modes.js';
import { gameRBG, gameHSL, gameHEXA } from './data/games.js';

import {
  gameBoardEl,
  gameFormEl,
  gameFieldSetEl,
  setTheBoard,
  playerColorBlocEl,
  colorInputsElRefObj,
  messageInputEls,
  buttonSubmitEl,
  messageBoxEl,
} from './elements';

import { initTimeout, timeoutId, intervalId } from './timeout';
import { initTriesRemaining, updateTriesRemaining } from './countOfTries';
import { createEndGameMessage } from './data/texts';

// TODO: add in lib file
let colorsRemainingToFind;
let game;

function displayMessage(message, color) {
  if (!color) console.log('display in a general element');
  let displayMessageEl = messageInputEls[`message-input-${color}`];
  displayMessageEl.textContent = message;
}

function colorFound(color) {
  colorInputsElRefObj[color].disabled = true;
  let updatedNamePropertiesToFind = colorsRemainingToFind.filter(
    (curr) => curr !== color
  );
  colorsRemainingToFind = updatedNamePropertiesToFind;
  if (!updatedNamePropertiesToFind.length) {
    // the game is finished, event endOfGame triggered
    gameBoardEl.dispatchEvent(
      new CustomEvent('endOfGame', {
        detail: {
          isVictory: true,
          timeoutID: timeoutId,
          intervalID: intervalId,
        },
      })
    );
    return;
  }
}

function evaluateAnswer(colorPlayer, colorToFind) {
  console.log({ colorPlayer, colorToFind });
  Object.keys(colorPlayer).forEach((color) => {
    let isTheSameColor = colorPlayer[color] === colorToFind[color];
    if (isTheSameColor) {
      // manage a color found
      displayMessage('✅', color);
      colorFound(color);
      return;
    } else if (colorPlayer[color] < colorToFind[color]) {
      displayMessage(`⬆️`, color);
    } else if (colorPlayer[color] > colorToFind[color]) {
      displayMessage(`⬇️`, color);
    } else {
      console.log(
        'something went wrong',
        colorPlayer[color],
        colorToFind[color]
      );
    }
  });
}

function handleSubmit(e) {
  e.preventDefault();
  const { formatColor, namePropertiesToFind } = game;
  const inputs = e.target.elements;
  // get the colors given by the player
  const valuesPlayer = namePropertiesToFind.reduce((acc, color) => {
    let isNumber = inputs[color].type === 'number';
    let playerInputVal = isNumber
      ? parseInt(inputs[color].value)
      : inputs[color].value.toLowerCase();

    inputs[color].setAttribute('value', inputs[color].value);

    return { ...acc, [color]: playerInputVal };
  }, {});
  const colorGeneratedByPlayerString = formatColor(valuesPlayer);
  // add background color generated by the player
  playerColorBlocEl.style.background = colorGeneratedByPlayerString;
  // evaluate answer
  evaluateAnswer(valuesPlayer, game.colorToFind);
  if (game.mode.isCountOfTries) {
    updateTriesRemaining();
  }
}

function handleEndOfGame(event) {
  console.log({ event });
  gameFieldSetEl.disabled = true;
  buttonSubmitEl.disabled = true;
  if (game.mode.isTimeout) {
    const { timeoutID = timeoutId, intervalID = intervalId } = event.detail;
    clearTimeout(timeoutID);
    clearInterval(intervalID);
  }
  const finalMessage = createEndGameMessage(event, game);
  messageBoxEl.innerHTML = finalMessage;
  messageBoxEl.hidden = false;
  // TODO: Manage Previous scores in LS (keep the 10 last best scores for each mode)
  // TODO: Display a restart button AND a go back to the select page
}

function gameLifeCycle({ isTimeout, isCountOfTries, difficulty, ...params }) {
  if (isTimeout) {
    // start timeout
    const { timeoutObjInMS } = params;
    let timeInMS = timeoutObjInMS[difficulty];
    initTimeout(timeInMS);
  }

  if (isCountOfTries) {
    const { triesAllowedObj } = params;
    // start to count tries
    initTriesRemaining(triesAllowedObj, difficulty);
  }

  gameFormEl.addEventListener('submit', handleSubmit);
  gameBoardEl.addEventListener('endOfGame', handleEndOfGame, { once: true });
}

function prepareGame(gameSelected, modeSelected) {
  game = {
    ...gameSelected,
    mode: { ...modeSelected },
  };
  // generate color
  game.colorToFind = game.generateColor();
  colorsRemainingToFind = game.namePropertiesToFind;
  // set the board
  setTheBoard(game);
  gameLifeCycle(game.mode);
}

// TODO: START When the player has selected the game + its mode
prepareGame(gameRBG, modeTest);
// prepareGame(gameHSL, modeTest);
// prepareGame(gameHEXA, modeTest);
