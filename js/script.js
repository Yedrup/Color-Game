import { modeTest } from './modes.js';
// TODO: conditional import
import { gameRBG, gameHSL, gameHEXA } from './games.js';
// TODO: logic to have the mode and game selected

import {
  gameBoardEl,
  gameFormEl,
  gameFieldSetEl,
  setTheBoard,
  playerColorBlocEl,
  colorInputsElRefObj,
  messageDisplayEls,
  buttonSubmitEl,
  timeIntervalTimeoutIds,
} from './elements';

// TODO: add in lib
let colorsRemainingToFind;
let game;

function displayMessage(message, color) {
  console.log(message, color);
  if (!color) console.log('display in a general element');
  let displayMessageEl = messageDisplayEls[`message-el-${color}`];
  console.log(colorInputsElRefObj[color], displayMessageEl);
  displayMessageEl.textContent = message;
}

function colorFound(color) {
  console.log('colorFound ✅', colorInputsElRefObj[color]);
  colorInputsElRefObj[color].disabled = true;
  let updatedNamePropertiesToFind = colorsRemainingToFind.filter(
    (curr) => curr !== color
  );
  console.log(updatedNamePropertiesToFind);
  colorsRemainingToFind = updatedNamePropertiesToFind;
  if (!updatedNamePropertiesToFind.length) {
    // the game is finished, event endOfGame triggered
    gameBoardEl.dispatchEvent(
      new CustomEvent('endOfGame', {
        detail: {
          victory: true,
          result: 'this is a great success',
        },
      })
    );
    return;
  }
}

function evaluateAnswer(colorPlayer, colorToFind) {
  console.log({ colorPlayer, colorToFind });
  Object.keys(colorPlayer).forEach((color) => {
    let isTheSameColor = colorPlayer[color] === colorToFind[color];
    if (isTheSameColor) {
      // manage a color found
      displayMessage('✅', color);
      colorFound(color);
      return;
    } else if (colorPlayer[color] < colorToFind[color]) {
      displayMessage(`⬆️`, color);
    } else if (colorPlayer[color] > colorToFind[color]) {
      displayMessage(`⬇️`, color);
    } else {
      console.log(
        'something went wrong',
        colorPlayer[color],
        colorToFind[color]
      );
    }
  });
}

function handleSubmit(e) {
  e.preventDefault();
  console.dir(e);
  console.log('game', game);
  const { formatColor, namePropertiesToFind } = game;
  const inputs = e.target.elements;
  // get the colors given by the player
  const valuesPlayer = namePropertiesToFind.reduce((acc, color) => {
    let isNumber = inputs[color].type === 'number';
    let playerInputVal = isNumber
      ? parseInt(inputs[color].value)
      : inputs[color].value.toLowerCase();

    inputs[color].setAttribute('value', inputs[color].value);

    return { ...acc, [color]: playerInputVal };
  }, {});
  const colorGeneratedByPlayerString = formatColor(valuesPlayer);
  // add background color generated by the player
  playerColorBlocEl.style.background = colorGeneratedByPlayerString;
  // evaluate answer
  evaluateAnswer(valuesPlayer, game.colorToFind);
}

function handleEndOfGame(event) {
  console.log('THIS is the end', event);
  gameFieldSetEl.disabled = true;
  buttonSubmitEl.disabled = true;
  if (game.mode.isTimeout) {
    const { timeoutId, intervalId } = timeIntervalTimeoutIds;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
  }
  // clear board
  // display message
  /* finish the game
   * display message + score
   * save in LS
   */
}

function gameLifeCycle() {
  gameFormEl.addEventListener('submit', handleSubmit);
  gameBoardEl.addEventListener('endOfGame', handleEndOfGame);
}

function prepareGame(gameSelected, modeSelected) {
  game = {
    ...gameSelected,
    mode: { ...modeSelected },
  };
  // generate color
  game.colorToFind = game.generateColor();
  colorsRemainingToFind = game.namePropertiesToFind;
  // set the board
  setTheBoard(game);
  gameLifeCycle();
}

// TODO: START When the player has selected the game + its mode
prepareGame(gameRBG, modeTest);
// prepareGame(gameHSL, modeTest);
// prepareGame(gameHEXA, modeTest);
